<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        body { font-family: 'JetBrains Mono', monospace; }
        canvas { image-rendering: pixelated; }
    </style>
</head>
<body class="bg-gray-950 text-white min-h-screen flex flex-col items-center justify-center select-none touch-none">
    <div class="relative flex flex-col md:flex-row gap-6 p-6 bg-gray-900 rounded-2xl shadow-2xl border border-gray-800 items-start">
        
        <!-- Left Stats & Hold -->
        <div class="flex flex-col gap-4 w-32 md:w-40">
            <div class="bg-gray-800 p-3 rounded-xl border border-gray-700 shadow-inner flex flex-col items-center">
                <h3 class="text-xs text-gray-400 uppercase font-bold mb-2 tracking-wider">Hold</h3>
                <canvas id="holdCanvas" width="100" height="80" class="w-full"></canvas>
            </div>
            <div class="bg-gray-800 p-4 rounded-xl border border-gray-700 shadow-inner flex flex-col gap-4 text-right">
                <div>
                    <p class="text-[10px] text-gray-400 uppercase tracking-widest">Score</p>
                    <p id="score" class="text-xl font-bold text-white">0</p>
                </div>
                <div>
                    <p class="text-[10px] text-gray-400 uppercase tracking-widest">Level</p>
                    <p id="level" class="text-xl font-bold text-yellow-400">1</p>
                </div>
                <div>
                    <p class="text-[10px] text-gray-400 uppercase tracking-widest">Lines</p>
                    <p id="lines" class="text-xl font-bold text-blue-400">0</p>
                </div>
            </div>
        </div>
        <!-- Main Game Board -->
        <div class="relative border-8 border-gray-800 bg-black rounded-md shadow-2xl">
            <canvas id="gameCanvas" width="300" height="600" class="block bg-gray-950"></canvas>
            
            <!-- Overlay -->
            <div id="overlay" class="absolute inset-0 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center z-10">
                <h1 class="text-4xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">TETRIS</h1>
                <p id="finalScore" class="text-gray-300 mb-6 hidden">Score: 0</p>
                <button id="startBtn" class="px-8 py-3 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 rounded-lg text-white font-bold shadow-lg transform transition hover:scale-105 active:scale-95 ring-2 ring-blue-400/50">
                    START GAME
                </button>
                <p class="mt-6 text-xs text-gray-500">Press P to Pause</p>
            </div>
        </div>
        <!-- Right Stats & Next -->
        <div class="flex flex-col gap-4 w-32 md:w-40 h-full">
            <div class="bg-gray-800 p-3 rounded-xl border border-gray-700 shadow-inner flex flex-col items-center">
                <h3 class="text-xs text-gray-400 uppercase font-bold mb-2 tracking-wider">Next</h3>
                <canvas id="nextCanvas" width="100" height="100" class="w-full"></canvas>
            </div>
            <div class="bg-gray-800/50 p-4 rounded-xl border border-gray-700/50 mt-auto text-[11px] text-gray-400 space-y-2 hidden md:block">
                <div class="flex justify-between"><span class="text-white font-bold">Arrows</span> <span>Move</span></div>
                <div class="flex justify-between"><span class="text-white font-bold">Up</span> <span>Rotate</span></div>
                <div class="flex justify-between"><span class="text-white font-bold">Down</span> <span>Soft</span></div>
                <div class="flex justify-between"><span class="text-white font-bold">Space</span> <span>Hard</span></div>
                <div class="flex justify-between"><span class="text-white font-bold">C</span> <span>Hold</span></div>
                <div class="flex justify-between"><span class="text-white font-bold">P</span> <span>Pause</span></div>
            </div>
        </div>
    </div>
    <script>
        // --- Constants & Config ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const PREVIEW_BLOCK_SIZE = 20;
        
        const COLORS = {
            'I': '#06b6d4', // Cyan
            'O': '#facc15', // Yellow
            'T': '#a855f7', // Purple
            'S': '#22c55e', // Green
            'Z': '#ef4444', // Red
            'J': '#3b82f6', // Blue
            'L': '#f97316', // Orange
            'ghost': 'rgba(255, 255, 255, 0.15)'
        };
        // Tetromino definitions
        const PIECES = {
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            'O': [[2,2],[2,2]], // Using numbers for internal logic, mapped to keys
            'T': [[0,3,0],[3,3,3],[0,0,0]],
            'S': [[0,4,4],[4,4,0],[0,0,0]],
            'Z': [[5,5,0],[0,5,5],[0,0,0]],
            'J': [[6,0,0],[6,6,6],[0,0,0]],
            'L': [[0,0,7],[7,7,7],[0,0,0]]
        };
        
        // Mapping numbers back to keys for color lookup
        const ID_TO_KEY = [null, 'I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        // --- Game State ---
        let canvas = document.getElementById('gameCanvas');
        let ctx = canvas.getContext('2d');
        let nextCanvas = document.getElementById('nextCanvas');
        let nextCtx = nextCanvas.getContext('2d');
        let holdCanvas = document.getElementById('holdCanvas');
        let holdCtx = holdCanvas.getContext('2d');
        let grid = createGrid(COLS, ROWS);
        let bag = [];
        let piece = null;
        let nextPiece = null;
        let holdPiece = null;
        let canHold = true;
        
        let score = 0;
        let level = 1;
        let lines = 0;
        
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let isGameActive = false;
        // DOM Elements
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const linesEl = document.getElementById('lines');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startBtn');
        const finalScoreEl = document.getElementById('finalScore');
        const overlayTitle = overlay.querySelector('h1');
        // --- Helper Functions ---
        
        function createGrid(w, h) {
            return Array.from({ length: h }, () => Array(w).fill(0));
        }
        function resetGame() {
            grid = createGrid(COLS, ROWS);
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            bag = [];
            holdPiece = null;
            canHold = true;
            isGameOver = false;
            isPaused = false;
            isGameActive = true;
            
            updateStats();
            refillBag();
            nextPiece = getNextPiece();
            spawnPiece();
            
            overlay.classList.add('hidden');
            finalScoreEl.classList.add('hidden');
            lastTime = performance.now();
            requestAnimationFrame(update);
        }
        function refillBag() {
            const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            // Fisher-Yates shuffle
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            bag.push(...pieces);
        }
        function getNextPiece() {
            if (bag.length === 0) refillBag();
            const key = bag.shift();
            const matrix = PIECES[key];
            // Identify ID:
            let id = 0;
            matrix.some(row => row.some(val => { if(val !== 0) id = val; return val !== 0; }));
            return {
                matrix: matrix,
                id: id,
                key: key,
                x: 0,
                y: 0
            };
        }
        function spawnPiece() {
            piece = nextPiece;
            nextPiece = getNextPiece();
            canHold = true;
            
            // Center piece
            piece.x = Math.floor((COLS - piece.matrix[0].length) / 2);
            piece.y = 0;
            // Check immediate collision (Game Over)
            if (collide(grid, piece)) {
                gameOver();
            }
            
            drawPreviews();
        }
        function collide(arena, player) {
            const m = player.matrix;
            const o = { x: player.x, y: player.y };
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        function rotate(matrix, dir) {
            // Transpose
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            // Reverse rows (CW) or columns (CCW)
            if (dir > 0) {
                matrix.forEach(row => row.reverse());
            } else {
                matrix.reverse();
            }
        }
        function playerRotate(dir) {
            const pos = piece.x;
            let offset = 1;
            rotate(piece.matrix, dir);
            // Wall kick (basic)
            while (collide(grid, piece)) {
                piece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > piece.matrix[0].length) {
                    rotate(piece.matrix, -dir);
                    piece.x = pos;
                    return;
                }
            }
        }
        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.y][x + player.x] = value;
                    }
                });
            });
        }
        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = grid.length - 1; y > 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                rowCount++;
            }
            
            if (rowCount > 0) {
                // Scoring (Nintendo system)
                const lineScores = [0, 40, 100, 300, 1200];
                score += lineScores[rowCount] * level;
                lines += rowCount;
                
                // Level up every 10 lines
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // Speed up
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100); 
                }
                
                updateStats();
            }
        }
        function updateStats() {
            scoreEl.innerText = score.toLocaleString();
            levelEl.innerText = level;
            linesEl.innerText = lines;
        }
        function holdCurrentPiece() {
            if (!canHold) return;
            
            const currentKey = piece.key;
            const currentId = piece.id; // Actually we recreate from key to be safe
            if (holdPiece === null) {
                holdPiece = { key: currentKey }; // Just store key
                spawnPiece();
            } else {
                const tempKey = holdPiece.key;
                holdPiece = { key: currentKey };
                
                // Restore the held piece
                const matrix = PIECES[tempKey];
                let id = 0;
                matrix.some(row => row.some(val => { if(val !== 0) id = val; return val !== 0; }));
                
                piece = {
                    matrix: JSON.parse(JSON.stringify(matrix)), // deep copy to reset rotation
                    id: id,
                    key: tempKey,
                    x: Math.floor((COLS - matrix[0].length) / 2),
                    y: 0
                };
            }
            
            canHold = false;
            drawPreviews();
        }
        // --- Drawing ---
        function drawMatrix(matrix, offset, context, blockSize, ghost = false) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const key = ID_TO_KEY[value];
                        context.fillStyle = ghost ? COLORS['ghost'] : COLORS[key];
                        context.fillRect(
                            (x + offset.x) * blockSize,
                            (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                        
                        // Inner bevel effect
                        if (!ghost) {
                            context.lineWidth = 2;
                            context.strokeStyle = 'rgba(0,0,0,0.1)';
                            context.strokeRect(
                                (x + offset.x) * blockSize,
                                (y + offset.y) * blockSize,
                                blockSize,
                                blockSize
                            );
                            
                            context.fillStyle = 'rgba(255,255,255,0.2)';
                            context.fillRect(
                                (x + offset.x) * blockSize,
                                (y + offset.y) * blockSize,
                                blockSize, 4
                            );
                        }
                    }
                });
            });
        }
        function drawGrid() {
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Subtle Grid Lines
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            drawMatrix(grid, {x: 0, y: 0}, ctx, BLOCK_SIZE);
        }
        function drawGhost() {
            const ghost = {
                matrix: piece.matrix,
                x: piece.x,
                y: piece.y
            };
            
            while (!collide(grid, ghost)) {
                ghost.y++;
            }
            ghost.y--; // Move back one step
            
            drawMatrix(ghost.matrix, {x: ghost.x, y: ghost.y}, ctx, BLOCK_SIZE, true);
        }
        function draw() {
            drawGrid();
            drawGhost();
            drawMatrix(piece.matrix, {x: piece.x, y: piece.y}, ctx, BLOCK_SIZE);
        }
        function drawPreviews() {
            // Next Piece
            nextCtx.fillStyle = '#1f2937';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                // Center it
                const mx = nextPiece.matrix;
                const w = mx[0].length * PREVIEW_BLOCK_SIZE;
                const h = mx.length * PREVIEW_BLOCK_SIZE;
                const ox = (nextCanvas.width - w) / 2 / PREVIEW_BLOCK_SIZE;
                const oy = (nextCanvas.height - h) / 2 / PREVIEW_BLOCK_SIZE;
                drawMatrix(mx, {x: ox, y: oy}, nextCtx, PREVIEW_BLOCK_SIZE);
            }
            // Hold Piece
            holdCtx.fillStyle = '#1f2937';
            holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (holdPiece) {
                const key = holdPiece.key;
                const mx = PIECES[key];
                // We need to fake a matrix with correct ID for color lookup
                // But PIECES already has ids.
                const w = mx[0].length * PREVIEW_BLOCK_SIZE;
                const h = mx.length * PREVIEW_BLOCK_SIZE;
                const ox = (holdCanvas.width - w) / 2 / PREVIEW_BLOCK_SIZE;
                const oy = (holdCanvas.height - h) / 2 / PREVIEW_BLOCK_SIZE;
                drawMatrix(mx, {x: ox, y: oy}, holdCtx, PREVIEW_BLOCK_SIZE);
            }
        }
        // --- Game Loop ---
        function playerDrop() {
            piece.y++;
            if (collide(grid, piece)) {
                piece.y--;
                merge(grid, piece);
                arenaSweep();
                spawnPiece();
            }
            dropCounter = 0;
        }
        
        function hardDrop() {
            while (!collide(grid, piece)) {
                piece.y++;
                score += 2; // Bonus for hard drop
            }
            piece.y--;
            merge(grid, piece);
            arenaSweep();
            updateStats();
            spawnPiece();
            dropCounter = 0;
        }
        function playerMove(dir) {
            piece.x += dir;
            if (collide(grid, piece)) {
                piece.x -= dir;
            }
        }
        function gameOver() {
            isGameOver = true;
            isGameActive = false;
            overlayTitle.innerText = "GAME OVER";
            finalScoreEl.innerText = `Final Score: ${score.toLocaleString()}`;
            finalScoreEl.classList.remove('hidden');
            overlay.classList.remove('hidden');
            startBtn.innerText = "PLAY AGAIN";
        }
        function togglePause() {
            if (!isGameActive || isGameOver) return;
            
            isPaused = !isPaused;
            if (isPaused) {
                overlayTitle.innerText = "PAUSED";
                finalScoreEl.classList.add('hidden');
                overlay.classList.remove('hidden');
                startBtn.innerText = "RESUME";
            } else {
                overlay.classList.add('hidden');
                lastTime = performance.now();
                requestAnimationFrame(update);
            }
        }
        function update(time = 0) {
            if (isPaused || !isGameActive) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            draw();
            requestAnimationFrame(update);
        }
        // --- Input Handling ---
        
        document.addEventListener('keydown', event => {
            if (event.key === 'Enter' && !isGameActive) {
                 resetGame();
                 return;
            }
            
            if (!isGameActive) return;
            
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
            }
            if (isPaused) return;
            if (event.key === 'ArrowLeft') {
                playerMove(-1);
            } else if (event.key === 'ArrowRight') {
                playerMove(1);
            } else if (event.key === 'ArrowDown') {
                playerDrop();
            } else if (event.key === 'ArrowUp') {
                playerRotate(1);
            } else if (event.key === ' ') { // Space
                hardDrop();
            } else if (event.key === 'c' || event.key === 'C') {
                holdCurrentPiece();
            }
        });
        startBtn.addEventListener('click', () => {
            if (isPaused && isGameActive) {
                togglePause();
            } else {
                resetGame();
            }
        });
        // Initial draw to show grid
        drawGrid();
        
        // Mobile Touch Controls (Simple Tap Zones)
        // We can implement basic touch handling if needed, but keyboard is primary per prompt implication.
        // Just ensuring it works on desktop first.
    </script>
</body>
</html>
